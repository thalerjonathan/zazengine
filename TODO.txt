Force core-profile when creating opengl context from windows
	-> http://www.opengl.org/discussion_boards/archive/index.php/t-175619.html
	-> http://www.opengl.org/wiki/Creating_an_OpenGL_Context_(WGL)
	-> http://www.opengl.org/registry/specs/ARB/wgl_create_context.txt
	
Sky-Box
	-> use cube-map instead of 6 textures all bound individually => better performance!
		 -> http://www.keithlantz.net/2011/10/rendering-a-skybox-using-a-cube-map-with-opengl-and-glsl/
	-> shadowing of sky-box not wanted: if materialType == skybox then don't apply shadowing!
	-> render AFTER other geometry and utilize stencil-buffer to mask fragments occluding the sky-box
			
Remove Get* OpenGL-calls in main loop
	-> Problem of texture-switching: mus implement in render-target too, must know from each other

Remove errors in gDEBugger during glLinkProgram!

Calculate position in Fragment-Shader
	-> use screen-coordinates & depth instead of spending a whole buffer on it
	-> compare Performance!!
From Object-Coordinates to Viewport-Coordinates
1. Input of object coordinates  aka object-space
		modeling transform
2. world-coordinates aka world-space
		viewing transform
3. view-coordinates ( aka eye-coordinates or eye-space)
		projection transform
4. clip-coordinates ( aka clip-space ): all in range of -/+ clip-volume
		perspective division
5. normaliced device coordinates ( NDC ): all in range from -1 to +1 (center is 0/0/0 )
		view-port transform
6. viewport coordinates: all in range from 0/0 to resolutionX/resolutionY of viewport
7. fragment-shader operates on viewport coordinates
From Viewport- to View-Space Coordinates
1. Input of Viewport-Coordinates AND depth in NDC-space for each fragment
		transform x & y to NDC: 
			- divide by resolutionX/resolutionY => range from 0 to 1
			- transform x by: x * 2 - 1 => in range from -1 to 1
			- transform y by: ( 1 - y ) * 2 - 1 => in range from -1 to 1: need to take care of the origin! it makes a difference wheter its in the left UPPER or left LOWER corner
2. NDC
		add depth to x & y-vector because now all in same space
3. clip-coordinates
		apply inverse projection transformation to position
		divide by w to transform back to homogenous coordinates
		( in perspective projection the perspective division by w is done => the inverse would be multiplication 
		  but we apply the inverse projection transform => need again to divide )
4. view-coordinates

Implement logging to file
	-> boost log: implement interface in ICore for logging
	-> make configurable: to console or to file (rotating file size,...)
	
Program- & Shader-Management
	-> describe by xml, is VERY annoying to manually set up in program-code
	-> frag-data location
	-> bind uniform blocks
	-> use glValidateProgram !
	-> lookup program in program-registry during runtime
	-> implement #include in shaders: parse loaded string and replace
		-> problem: compiler error generate other line numbers!

Transparency-Rendering
1. G-Buffer as usual
2. Lighting-Stage
	-> render transparent object in shadow-map generation AND write color of transparent object to additional color-texture in shadow-fbo
		=> need additional render-target in shadow-fbo: shadow-color target
	-> during light-rendering: when fragment in shadow do an additional lookup into the shadow-color texture to get the shadow-color for this fragment
	=> opaque Objects in Framebuffer AND colored shadows cast by transparent objects but no transparent objects yet
3. Render transparent objects 
	-> now render transparent objects by accessing previous framebuffer & pertubing the normals (no need to transform, we are already in tangent - texture - space )
		=> all black but transparent objects will show up
4. finalize
	-> combine both the opaque framebuffer and the transparent framebuffer into final framebuffer result:
		 marked pixel of transparent framebuffer will just overwrite pixels of opaque framebuffer	
	
Multiple lights
	-> blending 
	-> correct lighting-equations: falloff, cone, ...
		-> point-light
	-> Solve Problem of Ambient + Sky-Box Lighting
		-> when no directional light in scene
			-> render full-screen quad and apply ambient-term to non-sky-box material and diffuse-only to sky-box material => need new program
			-> other lights accumulate by blending
		-> when directional light in scene
			-> include ambient-term in non-sky-box material and diffuse-only to sky-box material 

Normal-mapping
	-> need to transform view-space normal of the object instead of transforming the viewing-direction and the light-direction to tangent-space
		-> why? because we have no more access to each tangent&bitangent in the lighting-pass and storing them in additional render-targets would be by far too much of overhead
		=> do it in geometry-stage fragment-shader
		
Shadow-mapping
	-> shadow-mapping of point-light
	-> do some sampling on shadow-edges

Reflections
	-> environment (cube-mapping)
	-> planar (?)
		
Msaa
	-> do sampling in geometry fragment-shader (centroid)

Text-rendering
	-> for displaying stuff e.g. framerate
	
Do View-Frustum culling
	-> Culling library (Umbra 3) ?
	
Need generic effect/material functionality
	-> on top of program- & shader-management
	-> based upon effect-files like directx/cg shader effects
	-> custom shader program for material programming
	-> problem: shaders-effect architecture from 2003 is based upon forward-rendering, we need now to plug it into deferred rendering
		-> 2 stages: geometry & ligting => potential up to 4 shaders/material: vertex&fragment in geometry & lighting
			-> BUT: vertex in geometry- & lighting-stage is very hard wired to deferred rendering
	-> important FIRST finish all special algorithms: shadow mapping, normal mapping, transparency, lighting, reflections, MSAA, ... (?)
	-> can be seen as a generic framework to implement BRDFs (?)
		-> sub-surface-scattering
		-> cook torrance sparrow
		-> subsurface scattering
		-> microfacet
	
Post-Processing in Screen-Space
	-> HDR
	-> Bloom
	-> Tone-Mapping
	-> Depth Of Field
	-> GI
	
Allow Toggle fullscreen
	-> reinit window & render-context!
		=> need to reinig glew, programs, textures,... (?)
		=> lot of work to do, because everything needs to be re-init-able

Optimization WHEN RENDERER HAS FINISHED, NOT BEFORE!!!
	-> pre multiply matrices in CPU instead of doing in shaders
	-> reduce branching in shaders (need different shader-architecture, see below)
	-> Experiment with different render-target formats for performance
	-> really all calls necessary e.g. always bindBuffer, ... ? are some states stored in buffers?

Game-Functionality
	-> allow mutliple scenes which can be changed during runtime. also specify which subsystems are necessary: load/unload them during runtime

Scenes
- brdf & model gallery
	-> famous models with all different brdfs placed in scene like in a gallery
	-> advanced brdfs
	-> shadowing
	-> lighting
	-> find some interesting "skybox" or surrounding model: http://www.3dmodelfree.com/

	Famous models (Stanford http://graphics.stanford.edu/data/3Dscanrep/ & Utah Teapot)
	-> teapot
	-> bunny
	-> dragon
	-> happy buddah
	-> armadillo
	-> lucy
	-> Asian Dragon
	-> Thai Statue

- qualcomm presentation
- chess
	-> show the chess-board 
	-> different material for black & white
	-> board reflects
	-> white transparent
	-> black subsurface scattering brdf
- rotating hyperdrive
	-> point light in center
	-> interesting shadow situation
- physics
	-> mesh
	-> spheres
	-> oder models fall down
	
Multithreading
- make physics processing async

Scripting
- TODO implement during FH-course on computer-languages

Code-Quality
- const-completeness (add const to inline methods were appropriate)
- replace all strcmp with boost:iequals
- keep id, type & core in ISubSystem as readable
- remove friend-initialisation bullshit from entities
- project buildable as RELEASE
- check if everything is cleaned up when a subsystem cannot be initialized
- A GOOD SOLUTION FOR THE PROBLEM OF INCLUDING TINY-XML IN ALL SUBSYSTEMS
- fmod-subsystem should do a proper loading and managing of its loaded sound (same as e.g. textures in graphics)
- UNIT-Tests?
